# GitLab CI/CD pipeline for JetStreamDB
# Tests all server implementations (C, Go, Node.js, Python) with comprehensive test suite

stages:
  - test

variables:
  JETSTREAM_URL: "http://127.0.0.1:7777"
  DATA_DIR: "/data"

before_script:
  - apt-get update -qq && apt-get install -y -qq build-essential golang-go nodejs npm python3 python3-pip curl wget timeout procps
  - mkdir -p $DATA_DIR
  - chmod +x test_jetstream.sh

test_c:
  stage: test
  image: ubuntu:22.04
  timeout: 5m
  script:
    # Compile C server
    - echo "Compiling JetStreamDB C server..."
    - gcc -o main main.c -lpthread -lssl -lcrypto -lcurl -ljansson -w
    - echo "C server compiled successfully"
    
    # Start C server in background
    - echo "Starting JetStreamDB C server..."
    - ./main &
    - SERVER_PID=$!
    - echo "Server started with PID $SERVER_PID"
    
    # Wait for server to start (max 30 seconds)
    - echo "Waiting for server to start..."
    - for i in {1..30}; do
        if curl -s --connect-timeout 2 $JETSTREAM_URL > /dev/null 2>&1; then
          echo "Server is ready after ${i} seconds";
          break;
        fi;
        if [ $i -eq 30 ]; then
          echo "Server failed to start within 30 seconds";
          kill $SERVER_PID 2>/dev/null || true;
          exit 1;
        fi;
        sleep 1;
      done
    
    # Run tests with timeout
    - echo "Running JetStreamDB tests..."
    - timeout 60s ./test_jetstream.sh > test_output_c.log 2>&1 || TEST_EXIT_CODE=$?
    - TEST_EXIT_CODE=${TEST_EXIT_CODE:-0}
    
    # Kill server process
    - echo "Stopping server..."
    - kill $SERVER_PID 2>/dev/null || true
    - sleep 2
    - kill -9 $SERVER_PID 2>/dev/null || true
    
    # Check test results
    - echo "Test output:"
    - cat test_output_c.log
    - echo "Checking for test failures..."
    - if grep -q "❌" test_output_c.log; then
        echo "Tests failed - found ❌ characters in output";
        exit 1;
      fi
    - if [ $TEST_EXIT_CODE -ne 0 ]; then
        echo "Tests failed with exit code $TEST_EXIT_CODE";
        exit 1;
      fi
    - echo "All C tests passed successfully!"
  
  artifacts:
    when: always
    paths:
      - test_output_c.log
    expire_in: 1 week
  
  after_script:
    # Cleanup: ensure server is killed even if job fails
    - pkill -f "./main" 2>/dev/null || true
    - rm -rf $DATA_DIR/* 2>/dev/null || true

test_go:
  stage: test
  image: ubuntu:22.04
  timeout: 5m
  script:
    # Start Go server in background
    - echo "Starting JetStreamDB Go server..."
    - go run main.go &
    - SERVER_PID=$!
    - echo "Server started with PID $SERVER_PID"
    
    # Wait for server to start (max 30 seconds)
    - echo "Waiting for server to start..."
    - for i in {1..30}; do
        if curl -s --connect-timeout 2 $JETSTREAM_URL > /dev/null 2>&1; then
          echo "Server is ready after ${i} seconds";
          break;
        fi;
        if [ $i -eq 30 ]; then
          echo "Server failed to start within 30 seconds";
          kill $SERVER_PID 2>/dev/null || true;
          exit 1;
        fi;
        sleep 1;
      done
    
    # Run tests with timeout
    - echo "Running JetStreamDB tests..."
    - timeout 60s ./test_jetstream.sh > test_output_go.log 2>&1 || TEST_EXIT_CODE=$?
    - TEST_EXIT_CODE=${TEST_EXIT_CODE:-0}
    
    # Kill server process
    - echo "Stopping server..."
    - kill $SERVER_PID 2>/dev/null || true
    - sleep 2
    - kill -9 $SERVER_PID 2>/dev/null || true
    
    # Check test results
    - echo "Test output:"
    - cat test_output_go.log
    - echo "Checking for test failures..."
    - if grep -q "❌" test_output_go.log; then
        echo "Tests failed - found ❌ characters in output";
        exit 1;
      fi
    - if [ $TEST_EXIT_CODE -ne 0 ]; then
        echo "Tests failed with exit code $TEST_EXIT_CODE";
        exit 1;
      fi
    - echo "All Go tests passed successfully!"
  
  artifacts:
    when: always
    paths:
      - test_output_go.log
    expire_in: 1 week
  
  after_script:
    # Cleanup: ensure server is killed even if job fails
    - pkill -f "go run main.go" 2>/dev/null || true
    - rm -rf $DATA_DIR/* 2>/dev/null || true

test_nodejs:
  stage: test
  image: ubuntu:22.04
  timeout: 5m
  script:
    # Start Node.js server in background
    - echo "Starting JetStreamDB Node.js server..."
    - node main.js &
    - SERVER_PID=$!
    - echo "Server started with PID $SERVER_PID"
    
    # Wait for server to start (max 30 seconds)
    - echo "Waiting for server to start..."
    - for i in {1..30}; do
        if curl -s --connect-timeout 2 $JETSTREAM_URL > /dev/null 2>&1; then
          echo "Server is ready after ${i} seconds";
          break;
        fi;
        if [ $i -eq 30 ]; then
          echo "Server failed to start within 30 seconds";
          kill $SERVER_PID 2>/dev/null || true;
          exit 1;
        fi;
        sleep 1;
      done
    
    # Run tests with timeout
    - echo "Running JetStreamDB tests..."
    - timeout 60s ./test_jetstream.sh > test_output_nodejs.log 2>&1 || TEST_EXIT_CODE=$?
    - TEST_EXIT_CODE=${TEST_EXIT_CODE:-0}
    
    # Kill server process
    - echo "Stopping server..."
    - kill $SERVER_PID 2>/dev/null || true
    - sleep 2
    - kill -9 $SERVER_PID 2>/dev/null || true
    
    # Check test results
    - echo "Test output:"
    - cat test_output_nodejs.log
    - echo "Checking for test failures..."
    - if grep -q "❌" test_output_nodejs.log; then
        echo "Tests failed - found ❌ characters in output";
        exit 1;
      fi
    - if [ $TEST_EXIT_CODE -ne 0 ]; then
        echo "Tests failed with exit code $TEST_EXIT_CODE";
        exit 1;
      fi
    - echo "All Node.js tests passed successfully!"
  
  artifacts:
    when: always
    paths:
      - test_output_nodejs.log
    expire_in: 1 week
  
  after_script:
    # Cleanup: ensure server is killed even if job fails
    - pkill -f "node main.js" 2>/dev/null || true
    - rm -rf $DATA_DIR/* 2>/dev/null || true

test_python:
  stage: test
  image: ubuntu:22.04
  timeout: 5m
  script:
    # Start Python server in background
    - echo "Starting JetStreamDB Python server..."
    - python3 main.py &
    - SERVER_PID=$!
    - echo "Server started with PID $SERVER_PID"
    
    # Wait for server to start (max 30 seconds)
    - echo "Waiting for server to start..."
    - for i in {1..30}; do
        if curl -s --connect-timeout 2 $JETSTREAM_URL > /dev/null 2>&1; then
          echo "Server is ready after ${i} seconds";
          break;
        fi;
        if [ $i -eq 30 ]; then
          echo "Server failed to start within 30 seconds";
          kill $SERVER_PID 2>/dev/null || true;
          exit 1;
        fi;
        sleep 1;
      done
    
    # Run tests with timeout
    - echo "Running JetStreamDB tests..."
    - timeout 60s ./test_jetstream.sh > test_output_python.log 2>&1 || TEST_EXIT_CODE=$?
    - TEST_EXIT_CODE=${TEST_EXIT_CODE:-0}
    
    # Kill server process
    - echo "Stopping server..."
    - kill $SERVER_PID 2>/dev/null || true
    - sleep 2
    - kill -9 $SERVER_PID 2>/dev/null || true
    
    # Check test results
    - echo "Test output:"
    - cat test_output_python.log
    - echo "Checking for test failures..."
    - if grep -q "❌" test_output_python.log; then
        echo "Tests failed - found ❌ characters in output";
        exit 1;
      fi
    - if [ $TEST_EXIT_CODE -ne 0 ]; then
        echo "Tests failed with exit code $TEST_EXIT_CODE";
        exit 1;
      fi
    - echo "All Python tests passed successfully!"
  
  artifacts:
    when: always
    paths:
      - test_output_python.log
    expire_in: 1 week
  
  after_script:
    # Cleanup: ensure server is killed even if job fails
    - pkill -f "python3 main.py" 2>/dev/null || true
    - rm -rf $DATA_DIR/* 2>/dev/null || true

